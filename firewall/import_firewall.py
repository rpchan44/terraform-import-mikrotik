#!/usr/bin/env python3
import os
import re
import sys
import subprocess
import socket
from librouteros import connect

HOST = "192.168.62.1"
USER = "terraform"
PASS = "terraform"
PORT = 8728

TF_FILE = "firewall.tf"
IMPORT_FILE = "firewall_imports.sh"


def connect_mikrotik(host, user, password, port):
    """Connect to MikroTik RouterOS via API."""
    try:
        api = connect(username=user, password=password, host=host, port=port, timeout=10)
        print(f"‚úÖ Connected to {host}:{port}")
        return api
    except (socket.timeout, OSError) as e:
        print(f"‚ùå Connection failed: {e}")
        sys.exit(1)


def sanitize_name(name):
    """Make Terraform-safe resource names."""
    return re.sub(r"[^a-zA-Z0-9_]", "_", name.lower().strip()) or "rule"


def fetch_rules(api, path, exclude_dynamic=True):
    """Fetch rules from MikroTik path, skipping dynamic ones if requested."""
    rules = []
    for rule in api.path(path):
        if exclude_dynamic and rule.get("dynamic") == "true":
            continue
        rules.append(rule)
    return rules


def generate_tf_block(resource_type, rule):
    """Convert a MikroTik rule to Terraform syntax."""
    comment = rule.get("comment", "")
    name = sanitize_name(comment or f"{resource_type}_{rule.get('.id', 'rule')}")
    attrs = []

    include_keys = [
        "chain",
        "action",
        "protocol",
        "src-address",
        "dst-address",
        "in-interface",
        "out-interface",
        "src-port",
        "dst-port",
        "to-addresses",
        "to-ports",
        "log",
        "log-prefix",
    ]

    for k in include_keys:
        if k in rule:
            attrs.append(f'  {k.replace("-", "_")} = "{rule[k]}"')

    if comment:
        attrs.append(f'  comment = "{comment}"')

    body = "\n".join(attrs)
    return name, f'resource "{resource_type}" "{name}" {{\n{body}\n}}\n'


def main():
    api = connect_mikrotik(HOST, USER, PASS, PORT)

    print("üì• Fetching firewall filter rules (non-dynamic)...")
    filters = fetch_rules(api, "ip/firewall/filter", exclude_dynamic=True)
    print(f"‚úÖ Found {len(filters)} filter rules")

    print("üì• Fetching firewall NAT rules...")
    nats = fetch_rules(api, "ip/firewall/nat", exclude_dynamic=False)
    print(f"‚úÖ Found {len(nats)} NAT rules")

    tf_blocks = []
    import_cmds = []

    # Filters
    for rule in filters:
        name, block = generate_tf_block("routeros_ip_firewall_filter", rule)
        tf_blocks.append(block)
        import_cmds.append(f"terraform import routeros_ip_firewall_filter.{name} '{rule['.id']}'")

    # NATs
    for rule in nats:
        name, block = generate_tf_block("routeros_ip_firewall_nat", rule)
        tf_blocks.append(block)
        import_cmds.append(f"terraform import routeros_ip_firewall_nat.{name} '{rule['.id']}'")

    # Write Terraform configuration
    with open(TF_FILE, "w") as f:
        f.write("# Generated automatically by import_firewall.py\n\n")
        f.write("\n".join(tf_blocks))
    print(f"‚úÖ Terraform configuration written to {TF_FILE}")

    # Write import commands
    with open(IMPORT_FILE, "w") as f:
        f.write("#!/bin/bash\n")
        f.write("# Generated by import_firewall.py\n\n")
        for cmd in import_cmds:
            f.write(cmd + "\n")
    os.chmod(IMPORT_FILE, 0o755)
    print(f"‚úÖ Terraform import commands written to {IMPORT_FILE}")

    # Execute terraform imports if terraform is available
    print("üöÄ Running terraform import commands...\n")
    for cmd in import_cmds:
        print("üîó", cmd)
        try:
            subprocess.run(cmd.split(), check=False)
        except FileNotFoundError:
            print("‚ö†Ô∏è Terraform not found in PATH. Skipping execution.")

    print("\nüéâ All rules exported and imported into Terraform state (if terraform was available).")


if __name__ == "__main__":
    main()

